{"componentChunkName":"component---src-templates-lesson-post-js","path":"/lesson/numbers","result":{"data":{"strapiLesson":{"id":"Lesson_14","author":{"email":"eric@ericwindmill.com","username":"Eric Windmill","twitter":"ericwindmill"},"content":"Dart supports sever built in types. These are the most common of the types that represent a single value.\n\n- int\n- double\n- num\n- String\n- bool\n\n### int\n\nAn `int` is a whole number (integer).\n\n```dart\nint one = 1;\nint age = 45;\nint year = 2020;\n\n// an int can be negative\nint balance = -45;\n```\n\n### double\n\nA `double` is a floating-point number, or a number with a decimal point. \n\n```dart\ndouble percent = .65;\ndouble rating = 4.5;\n\n// a double can be negative\ndouble negativeNumber = -87.42;\n```\n\n### num\n\n`num` is a super class of both `int` and `double`. Which means you can use `num` when dealing with numbers that could be an integer or floating-point number. They're best used when you don't know which of the types will be used.\n\n```dart\nnum sum;\n// now sum has an int value\nsum = 4 + 5;\n\n// by adding a double, sum now refers to a double value\nsum = sum + 5.5;\n```","updated_at":"Saturday, 18th of July, 2020","slug":"numbers","strapiId":14,"title":"Numbers","tutorial":{"category":"Dart","title":"Data Types"}},"strapiTutorial":{"lessons":[{"author":1,"content":"Dart supports many different types of _collections_, or data types that contain multiple values. The most common collections: \n\n- List (known as an array in some languages)\n- Set\n- Map\n\n### Maps\n\nA map, also known commonly as a dictionary or hash, is an _unordered_ collection of key-value pairs. Maps pair a key with a value for easy, fast retrieval. Like lists and sets, maps can be declared with a constructor or literal syntax.\n\n<div class='aside'>\n    Sets and maps have the the same syntax for their literal implementation. When you define a set literal, you must annotate the type of the variable. Otherwise, it will default to a `Map`.  \n</div>\n\n```dart\n// literal syntax\nvar dogsIvePet = {\n  'Golden Retriever': ['Cowboy', 'Jack'],\n  'Laberdoodles': ['Wallace', 'Phoebe'], \n  'Shepards': ['Doug', 'Steak'],\n}\n\n// constructor syntax\nvar dogsIWantToPet = Map();\n\n// create a key called 'Border Collie' and assign it's value\ndogsIWantToPet['Border Collie'] = ['Mike', 'Jackson'];\n```\n\nLike other collections, there are many class members on the `Map` class that make it more convenient to manipulate. A couple of them are:\n\n- `remove(key)`\n- `keys`\n- `values`\n- `length`\n- `isEmpty` and `isNotEmpty`\n- `containsKey(key)`\n\n```dart\nvar dogsIvePet = {\n  'Golden Retriever': ['Cowboy', 'Jack'],\n  'Laberdoodles': ['Wallace', 'Phoebe'], \n  'Shepherds': ['Doug', 'Steak'],\n}\n\n// remove an item\ndogsIvePet.remove('Laberdoodles');\n\n// length gives the number of key-value pairs\nprint(dogsIvePet.length);\n// output: 2\n\nprint(dogsIvePet.keys);\n// output: ['Golden Retriever', 'Shepherds']\n```\n\n<div class=\"aside\">\nLike lists, maps support collection-if, collection-for, and spread operators.\n</div>","created_at":"2020-07-18T17:16:47.921Z","id":20,"slug":"maps","title":"maps","tutorial":4,"updated_at":"2020-07-25T15:24:19.914Z"},{"author":1,"content":"`bool` is the Dart type that represents a boolean value.  It can be `true` or `false`.\n\n```dart\n// assign directly\nbool isPortland = true;\nbool isWinter = true;\n\n// You can combine booleans with &&, ||, and other symbols\n// if isPortland is true AND isWinter is true\nbool isRaining = isPortland && isWinter;\n\nif (isRaining) {\n  print(\"Grab an umbrella!\");\n} else {\n  print(\"The sun is shining!\");\n}\n\n// prints\n\"Grab an umbrella!\"\n```","created_at":"2020-07-18T17:14:43.256Z","id":16,"slug":"booleans","title":"Booleans","tutorial":4,"updated_at":"2020-07-18T17:14:43.265Z"},{"author":1,"content":"Dart supports many different types of _collections_, or data types that contain multiple values. The most common collections: \n\n- List (known as an array in some languages)\n- Set\n- Map\n\n### Sets\n\nSets are similar to lists, with two distinctions. While a `List` is ordered, a set is unordered. Also, the objects in a `Set` are _unique_. And that is a guarantee.\n\nFor example, if you have a `Set` of `int` objects, and you try to add `1` to the set twice, the second attempt simply won't work. It won't throw an error or fail in anyway. Instead, Dart will just realize that the `1` already exists in the set, and it'll move on. \n\nIn order to create a set, you use the set constructor function or a `Set` literal.\n\n```dart\n// with constructor\nSet<int> specialNumbers = Set();\n\n// set literal\nSet<int> literalSpecialNumbers = {1, 4, 6};\n```\n\n<div class='aside'>\n    Sets and maps have the the same syntax for their literal implementation. When you define a set literal, you must annotate the type of the variable. Otherwise, it will default to a `Map`.  \n</div>\n\nOther than that, interacting with a set is similar to interacting with a `List`. \n\n```dart\nSet<int> specialNumbers = Set();\n\nspecialNumbers.add(3);\nprint(specialNumbers);\n\nspecialNumbers.add(6);\nprint(specialNumbers);\n\n// won't get added!\nspecialNumbers.add(6);\nprint(specialNumbers);\n\n\n// output\n// => [3]\n// => [3, 6]\n// => [3, 6]\n```\n","created_at":"2020-07-18T17:16:17.814Z","id":19,"slug":"sets","title":"sets","tutorial":4,"updated_at":"2020-07-25T15:24:08.188Z"},{"author":1,"content":"### Inferring the type\n\nDart is a _typed language_. The type of the variable `message` is String. Dart can infer this\n type, so you did't have to explicitly define it as a String. Importantly, this variable must be\n  a String forever. You cannot re-assign the variable as an integer. If you did want to create a\n   variable that's more dynamic, you'd use the `dynamic` keyword. We'll see examples of that in a later lesson.\n   \n```dart\ndynamic message = 'Hello World';\n```\n\nYou can safely re-assign this variable to an integer. \n\n```dart\ndynamic message = 'Hello, World';\nmessage = 8; \n```\n\n*NB*: It's rarely advisable to use `dynamic`. Your code will benefit from being type safe.  ","created_at":"2020-07-18T17:15:17.428Z","id":17,"slug":"dynamic","title":"dynamic","tutorial":4,"updated_at":"2020-07-18T17:15:17.436Z"},{"author":1,"content":"Dart supports sever built in types. These are the most common of the types that represent a single value.\n\n- int\n- double\n- num\n- String\n- bool\n\n### int\n\nAn `int` is a whole number (integer).\n\n```dart\nint one = 1;\nint age = 45;\nint year = 2020;\n\n// an int can be negative\nint balance = -45;\n```\n\n### double\n\nA `double` is a floating-point number, or a number with a decimal point. \n\n```dart\ndouble percent = .65;\ndouble rating = 4.5;\n\n// a double can be negative\ndouble negativeNumber = -87.42;\n```\n\n### num\n\n`num` is a super class of both `int` and `double`. Which means you can use `num` when dealing with numbers that could be an integer or floating-point number. They're best used when you don't know which of the types will be used.\n\n```dart\nnum sum;\n// now sum has an int value\nsum = 4 + 5;\n\n// by adding a double, sum now refers to a double value\nsum = sum + 5.5;\n```","created_at":"2020-07-18T17:13:04.092Z","id":14,"slug":"numbers","title":"Numbers","tutorial":4,"updated_at":"2020-07-18T17:13:04.099Z"},{"author":1,"content":"Dart's type system is straightforward enough (as far as type systems go). But it is a big topic, especially if you've never used a typed language before. It's such a big topic that we can't possibly cover it in this lesson alone. This is just an introduction.\n\nBefore I became a Dart developer, I wrote Ruby, Python, and JavaScript, which are dynamic. When I started writing Dart, I found using types to be the biggest hurdle. (But now, I don't want to live in a world without them.)\n \nTo start, let's look at a few key places in which types are established in Dart.\n\n### When defining variables\n\nRather than using `var` to define variables, you can use the variables type.\n\n```dart\n// The name variable must be a String\nString name;\n\n// The age variable must be an int\nint age;\n```\n\nUsing types when defining variables prevents you from assigning values to variables that aren't\n compatible.\n\n```dart\n// doesn't work!\nint age = 'hello';\n```\n\nIf you try to run that file in your terminal, Dart will throw an error.\n\n```dart\nError: A value of type 'dart.core::String' can't be assigned to a variable of type 'dart.core::int'.\nTry changing the type of the left hand side, or casting the right hand side to 'dart.core::int'.\n```\n\nThis kind of build time error is what makes Dart _type safe_. Types ensure at compile time that your\n functions all get the right kind of data. \n\n<div class=\"aside\"> \nIf you're using one of the IDEs suggested in the appendix and have installed the Dart plugin, you won't even get that far. The linter will tell you you're using the wrong type straight away. This is, in a nutshell, the value of type systems.\n</div>\n\n### Types in functions\n\nTypes are also used to define the _return_ value of functions. The main function of every Dart program has a return type of `void`, because it doesn't return anything.\n\n```dart\n// void is the return type\nvoid main() {\n  print('hello world');\n}\n```\n\nAny function that's being used for its _side effects_ should have this return type. It means the function returns nothing. Other functions, though, should declare what they're going to return. This function returns an `String`:\n\n```dart\nString greeting() {\n  return \"Hello World\"; // returns this String\n}\n```\n\nThis would fail if you tried to return the wrong type.\n\n```dart\nString greeting() {\n  return 45; // fails, because 45 is an int!\n}\n```\n\nReturn types are also used in functions when defining the arguments that function expects. \n\n```dart\n// this function expects two integers\nint addNums(int x, int y) {\n  return x + y;\n}\n\n// you'd call it like this\nint sum = addNums(4, 5);\n\n// this wouldn't work\nint sum = addNums(3, \"five\"); // error!\n```\n\nDart has several built in types, which you can find [here]().","created_at":"2020-07-18T17:12:23.766Z","id":13,"slug":"intro-to-dart-s-type-system","title":"Intro to Dart's Type System","tutorial":4,"updated_at":"2020-07-18T17:12:23.777Z"},{"author":1,"content":"`String` is the basic class with which you write text.\n\n```dart\nString greeting = 'hello, world';\nString confirm = 'Press to Confirm';\nString userName = 'WallaceTheCat';\n```\n\nStrings can be concatenated with `+` operator, or by simply placing multiple strings next to eachother:\n\n```dart\nprint(\"Hello,\" + \" World\");\n// Hello, World\n\nprint (\"Hello\" \",\" \" World\");\n// Hello, World\n```\n\nYou can interpolate values into strings with the `$` operator for single values, and `${}` for expressions.\n\n```dart\nvar age = 29;\nprint(\"My age is $age\");\n// My age is 29\n\nprint(\"Next year I'll be ${age + 1}\");\n// Next year I'll be 30\n```\n\nThe `String` class includes a number of methods you can use to manipulate the text.\n\n```dart\nString greeting = 'howdy'\n\nprint(greeting.split(\"\")); \n// ['h', 'o', 'w', 'd', 'y']\n\nassert(greeting.length == 5) // true\n\nprint(greeting.indexOf('o'));\n// 2\n\nprint(greeting.contains(\"hat\"))\n// false\n``` ","created_at":"2020-07-18T17:14:02.613Z","id":15,"slug":"strings","title":"Strings","tutorial":4,"updated_at":"2020-07-18T17:14:02.621Z"},{"author":1,"content":"<div class='post-toc'>\n\nOn this page:\n\n* [Lists](#lists)\n* [Spread Operator](#spread-operator)\n* [Collection If](#collection-if)\n* [Collection For](#collection-for)\n\n</div>\n\nDart supports many different types of _collections_, or data types that contain multiple values. The most common collections: \n\n- List (known as an array in some languages)\n- Set\n- Map\n\n### Lists\n\nPerhaps the most common collection in nearly every programming language is the array, or ordered group of objects. In Dart, arrays are List objects, so most people just call them lists.\n\nDart list literals look like JavaScript array literals. Here's a simple Dart list:\n\n```dart\nvar list = List();\nlist.add(1, 2);\n\n// list literal definition\nvar list2 = [1, 2, 3];\n```\n\nDart infers that this is variable of type `List<int>`.  When using data structures like a `List` or `Map`, you use `<` and `>` to define the types of the values within the `List` or `Map`.\n\nThe above could also be written like this:\n\n```dart\nfinal List<int> list = [1, 2, 3];\n```\n\nBecause Dart is type safe, every member in a collection must be the same type. If you _really_ wanted a list with different types, you could define the list as `List<dynamic>`, but this is rarely useful.\n\nThe `List` class includes a number of members to manipulate a list.\n\n```dart\nfinal list = [1,2,3];\n\nassert(list.length == 3); // true\nprint(list.first);\n// 1\n\nprint(list.last);\n// 3\n\nlist.add(4);\nlist.addAll(5,6);\nprint(list);\n// [1,2,3,4,5,6]\n```\n\n### Spread operator\n\nLists support being \"spread out\" into other lists. The spread operator puts each element from a list into a target list.\n\n```dart\nvar list = [1,2,3];\nvar list2 = [0, ...list];\nprint(list2);\n// [0,1,2,3];\n\n\n// use null aware spread to avoid null-pointer crashes \nvar list3 = [0, ...?list2];\n```\n\n### Collection If\n\nYou can use simple `if` and `for` statements inside list literals in order to programmatically add values. You cannot include a code block with these `if` and `for` statements inside collections, you can only add single values.\n\n```dart\nbool showToday = false;\n\nvar listOfDays = [\n  \"Yesterday\", \n  if (showToday) \"Today\", // won't be added!\n  \"Tomorrow\",\n]; \n\nprint(listOfDays);\n// [\"Yesterday\", \"Tomorrow\"]\n```\n\n\n### Collection For\n\nCollection `for` is used to add multiple values to a list programmatically.\n\n<div class=\"example-label\"></div>\n\n```dart\nvar listOfDays = [\n  DateTime(2018, 5, 6), \n  DateTime(2016, 5, 7), \n  DateTime(2018, 5, 8),\n];\n\nvar humanReadableListOfDays = [\n  \"2018-05-05 00:00:00.000\",\n  for (var day in listOfDays) day.toString(),\n  \"2018-05-09 00:00:00.000\",\n];\n\nprint(humanReadableListOfDays);\n// [\"2018-05-05 00:00:00.000\", \"2018-05-06 00:00:00.000\", \"2018-05-07 00:00:00.000\", \"2018-05-08 00:00:00.000\", \"2018-05-09 00:00:00.000\",]\n\n\n```","created_at":"2020-07-18T17:15:46.896Z","id":18,"slug":"lists","title":"lists","tutorial":4,"updated_at":"2020-07-25T15:23:53.343Z"}]},"strapiTableOfContents":{"contents":"{\n  \"Dart\": {\n    \"Getting Started with Dart\": [\n      \"About Dart\",\n      \"Install Dart on your machine\",\n      \"Dartpad\",\n      \"Text Editors: Intellij and VSCode\",\n      \"Resources: Documentation and Pub.dev\",\n      \"Hello World\",\n      \"The main function\",\n      \"Print to the console\"\n    ],\n    \"Dart Fundamentals\": [\n      \"Values and variables\",\n      \"Comments\",\n      \"const and final variables\",\n      \"Arithmetic and Comparison Operators\",\n      \"Assignment Operators\",\n      \"Logical Operators\",\n      \"Null Aware Operators\",\n      \"Type Test Operators\",\n      \"Bitwise and Shift Operators\",\n      \"Control Flow: if, else, else if\",\n      \"Switch statements and case\",\n      \"Ternary Conditional operator\",\n      \"Loops: for and while\",\n      \"Anatomy of Dart Functions\",\n      \"Arrow functions\",\n      \"Function arguments: default, optional, named\",\n      \"Lexical Scope\",\n      \"Cascade notation\"\n    ],\n    \"Data Types\": [\n      \"Intro to Dart's Type System\",\n      \"Numbers\",\n      \"Strings\",\n      \"Booleans\",\n      \"dynamic\",\n      \"lists\",\n      \"sets\",\n      \"maps\"\n    ],\n    \"Object-Oriented Programming\": [\n      \"Intro to OOP\",\n      \"Classes\",\n      \"Constructors\",\n      \"Properties and methods\",\n      \"Methods: static, private, etc\",\n      \"Getters and setters\",\n      \"Extending classes (inheritance)\",\n      \"Initializer lists and final properties\",\n      \"Factory methods\",\n      \"Singletons\",\n      \"Abstract classes (and interfaces)\",\n      \"Mixins\",\n      \"Extension methods\"\n    ],\n    \"Iterables, Iterators, and Collections\": [\n      \"What are collections (and iterables)?\",\n      \"Looping: for-in and forEach\",\n      \"Reading elements pt 1: first, last\",\n      \"Adding elements: add and insert (all)\",\n      \"Checking for elements: contains, indexOf, any, every\",\n      \"Removing elements: remove, clear, removeWhere\",\n      \"Filtering elements: where, takeWhile, and skipWhile\",\n      \"Changing elements: map and expand\",\n      \"Deriving values from elements: fold, reduce, join\",\n      \"Type casting collections: cast, as, retype, toSet, toList\",\n      \"Iterators: understanding and creating your own\",\n      \"Iterable-like methods on maps (and putIfAbsent)\"\n    ]\n  },\n  \"Flutter\": {\n    \"Getting started with Flutter\": [\n      \"About Flutter\",\n      \"IDEs and resources\"\n    ],\n    \"Widgets\": [\n      \"Intro to Widgets\",\n      \"Widget types: Stateful and Stateless\",\n      \"StatefulWidget lifecycle\",\n      \"The Widget tree\",\n      \"BuildContext\",\n      \"Inherited Widgets\",\n      \"Thinking in widgets\"\n    ],\n    \"Intro Flutter App\": [\n      \"Intro and Setup\",\n      \"Data Model and HTTP\",\n      \"Build a custom widget\",\n      \"ListView and builder pattern\",\n      \"Gradient Backgrounds\",\n      \"Routing: Add a detail page\",\n      \"Routing 2: Add a form page\",\n      \"User Input\",\n      \"Sliders and Buttons\",\n      \"Snackbars and Dialogs\",\n      \"Built-in Animation: AnimatedCrossFade\",\n      \"Built-in Animation: Hero transition\"\n    ],\n    \"Custom Animation: Progress Indicator\": [\n      \"Intro and Overview\",\n      \"Build the example app boiler-plate\",\n      \"Custom Widget: Peg\",\n      \"Tween and AnimationController classes\",\n      \"Tween by example\",\n      \"Using Tweens and Intervals\",\n      \"Wrap the Pegs in AnimatedWidgets\",\n      \"Bring it all together\"\n    ],\n    \"State Management: Blocs without Libraries\": [\n      \"What are blocs?\",\n      \"Calendar App introduction\",\n      \"Create bloc one\",\n      \"Create a bloc provider\",\n      \"Using StreamBuilders with blocs\",\n      \"Create bloc two: Add/Edit Tasks\",\n      \"Consume the second bloc's streams\",\n      \"Complete source code\"\n    ],\n    \"State Management: Provider\": [\n      \"What is Provider?\",\n      \"The most basic example using Provider\",\n      \"ChangeNotifierProvider\",\n      \"Rebuilding widgets with Consumer\",\n      \"Finer build control with Selector\",\n      \"Future Provider\",\n      \"MultiProvider micro lesson\",\n      \"Stream Provider\",\n      \"Using context extensions for more control\",\n      \"ProxyProvider\",\n      \"Using .value constructors\",\n      \"The final example (A shopping cart app)\",\n      \"For the curious: How is provider implemented\"\n    ],\n    \"Handling Data with Brick: Offline First with Rest\": [\n      \"About Brick and setup\",\n      \"Adding a Repository\",\n      \"Adding a Model\",\n      \"Generating Code\",\n      \"Rendering Models\",\n      \"Adding an Association\"\n    ]\n  }\n}"}},"pageContext":{"slug":"numbers","tutorialTitle":"Data Types","previous":{"author":1,"content":"### Inferring the type\n\nDart is a _typed language_. The type of the variable `message` is String. Dart can infer this\n type, so you did't have to explicitly define it as a String. Importantly, this variable must be\n  a String forever. You cannot re-assign the variable as an integer. If you did want to create a\n   variable that's more dynamic, you'd use the `dynamic` keyword. We'll see examples of that in a later lesson.\n   \n```dart\ndynamic message = 'Hello World';\n```\n\nYou can safely re-assign this variable to an integer. \n\n```dart\ndynamic message = 'Hello, World';\nmessage = 8; \n```\n\n*NB*: It's rarely advisable to use `dynamic`. Your code will benefit from being type safe.  ","created_at":"2020-07-18T17:15:17.428Z","id":17,"slug":"dynamic","title":"dynamic","tutorial":4,"updated_at":"2020-07-18T17:15:17.436Z"},"next":{"author":1,"content":"Dart's type system is straightforward enough (as far as type systems go). But it is a big topic, especially if you've never used a typed language before. It's such a big topic that we can't possibly cover it in this lesson alone. This is just an introduction.\n\nBefore I became a Dart developer, I wrote Ruby, Python, and JavaScript, which are dynamic. When I started writing Dart, I found using types to be the biggest hurdle. (But now, I don't want to live in a world without them.)\n \nTo start, let's look at a few key places in which types are established in Dart.\n\n### When defining variables\n\nRather than using `var` to define variables, you can use the variables type.\n\n```dart\n// The name variable must be a String\nString name;\n\n// The age variable must be an int\nint age;\n```\n\nUsing types when defining variables prevents you from assigning values to variables that aren't\n compatible.\n\n```dart\n// doesn't work!\nint age = 'hello';\n```\n\nIf you try to run that file in your terminal, Dart will throw an error.\n\n```dart\nError: A value of type 'dart.core::String' can't be assigned to a variable of type 'dart.core::int'.\nTry changing the type of the left hand side, or casting the right hand side to 'dart.core::int'.\n```\n\nThis kind of build time error is what makes Dart _type safe_. Types ensure at compile time that your\n functions all get the right kind of data. \n\n<div class=\"aside\"> \nIf you're using one of the IDEs suggested in the appendix and have installed the Dart plugin, you won't even get that far. The linter will tell you you're using the wrong type straight away. This is, in a nutshell, the value of type systems.\n</div>\n\n### Types in functions\n\nTypes are also used to define the _return_ value of functions. The main function of every Dart program has a return type of `void`, because it doesn't return anything.\n\n```dart\n// void is the return type\nvoid main() {\n  print('hello world');\n}\n```\n\nAny function that's being used for its _side effects_ should have this return type. It means the function returns nothing. Other functions, though, should declare what they're going to return. This function returns an `String`:\n\n```dart\nString greeting() {\n  return \"Hello World\"; // returns this String\n}\n```\n\nThis would fail if you tried to return the wrong type.\n\n```dart\nString greeting() {\n  return 45; // fails, because 45 is an int!\n}\n```\n\nReturn types are also used in functions when defining the arguments that function expects. \n\n```dart\n// this function expects two integers\nint addNums(int x, int y) {\n  return x + y;\n}\n\n// you'd call it like this\nint sum = addNums(4, 5);\n\n// this wouldn't work\nint sum = addNums(3, \"five\"); // error!\n```\n\nDart has several built in types, which you can find [here]().","created_at":"2020-07-18T17:12:23.766Z","id":13,"slug":"intro-to-dart-s-type-system","title":"Intro to Dart's Type System","tutorial":4,"updated_at":"2020-07-18T17:12:23.777Z"}}},"staticQueryHashes":["2185715291","3564968493","63159454"]}