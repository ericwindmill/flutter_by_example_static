{"componentChunkName":"component---src-templates-blog-post-js","path":"/blog/using-flutter-inherited-widgets-effectively","result":{"data":{"strapiBlogPost":{"id":"Blog-post_3","user":{"email":"eric@ericwindmill.com","username":"Eric Windmill","twitter":"ericwindmill","bio":"Creator of Flutter by Example, Author Flutter in Action"},"content":"If you've used Flutter before, you've probably come accross the 'of' method on different classes here and there:\n\n```dart\nTheme.of(context).textTheme\nMediaQuery.of(context).size\n```\n\nThose widgets (Theme, MediaQuery) are Inherited widgets. Pretty much anywhere in your app, you can access your theme,\n because they're inherited.\n \nIn Flutter, every part of the sdk is exposed to the developer, so you can take advantage of the inherited widget \nyourself. You can use a custom InheritedWidget as a built-in central state storage, similar to a Redux Store or Vue's \nVuex Store.\n\nAfter you've set up a store like this, you'll be able to do something like this: \n\n```dart\nclass RedText extends StatelessWidget {\n  // ...\n  Widget build(BuildContext context) {\n    var state = StateContainer.of(context).state;\n    return new Text(\n      state.user.username,\n      style: const TextStyle(color: Colors.red),\n    );\n  // ...\n```\n\n### Lifting State Up\n\nWhen using an InheritedWidget as your state management tool, you're likely relying on an architecture pattern called \n'Lifting State Up'. \n\nConsider the starter Flutter app when you start a new project (the counter app). If you wanted to\n separate that app into two pages, one that displayed the counter, and one that allowed you to change the number. \n Suddenly, this incredibly simple app is confusing. Each time you change routes, you have to be passing this piece of\n  state (the counter) back and forth.\n  \nThe InheritedWidget solves this problem by giving an entire widget tree access to the same pieces of state. \n\n <img src=\"http://res.cloudinary.com/ericwindmill/image/upload/v1518974500/flutter_by_example/medium_tree.png\" />\n\nFor a super awesome detailed explanation of different Flutter architecture concepts, [watch Brain Egan's talk from \nDartConf 2018](https://www.youtube.com/watch?v=zKXz3pUkw9A&t=1467s). Just don't watch too much, or you'll be \nconvinced to use [flutter_redux](https://pub.dartlang.org/packages/flutter_redux), and you won't care about this article anymore. ðŸ™ƒ\n\nThe advantage to lifting state up rather than reaching for something like Redux, is that using an Inherited Widget is\n pretty simple to set up and use. \n \n**NB:** To be sure, I am a fan of Redux and Vuex and all the 'ux' things. This is just another tool in your toolbox \nfor when Redux is more than you need. \n\n### Why Bother?\n\nAt this point, you might be asking why you should bother with an InheritedWidget. Why not just stick with a stateful \nwidget at the apps root? \n\nWell really, that's what you are doing here. The inherited widget works in conjunction with a stateful widget and \nallows you to pass that StatefulWidgets state to *all* of its ancestors. Its a convenience widget. So you don't have \nto type the code in every class to pass state down to its children.\n\n##Pt: 1 Set up a boiler plate app\n\nFor this example, let's just make this simple app:\n\n<img src=\"http://res.cloudinary.com/ericwindmill/image/upload/v1523742041/blog_posts/inherited_test.gif\" />\n\nBasically this app's state is lifted up above the root Widget, and when you submit the form, it calls `setState` on \nthat inherited widgets state, which tells the main page that there's new information to render.\n\n### 1. The Material App Root\n\nThis is just your standard Flutter app set up:\n\n```dart\nvoid main() {\n  runApp(new UserApp());\n}\n\nclass UserApp extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return new MaterialApp(\n      home: new HomeScreen(),\n    );\n  }\n}\n```\n\n### 2. HomeScreen Widget\n\nThis is also very basic, for now. This is just boiler plate you need to follow along when the good stuff comes.\n\n```dart\nclass HomeScreen extends StatefulWidget {\n  @override\n  HomeScreenState createState() => new HomeScreenState();\n}\n\nclass HomeScreenState extends State<HomeScreen> {\n  \n  Widget get _logInPrompt {\n    return new Center(\n      child: new Column(\n        mainAxisAlignment: MainAxisAlignment.center,\n        crossAxisAlignment: CrossAxisAlignment.center,\n        children: <Widget>[\n          new Text(\n            'Please add user information',\n            style: const TextStyle(fontSize: 18.0),\n          ),\n        ],\n      ),\n    );\n  }\n  \n  // All this method does is bring up the form page.\n  void _updateUser(BuildContext context) {\n    Navigator.push(\n      context,\n      new MaterialPageRoute(\n        fullscreenDialog: true,\n        builder: (context) {\n          return new UpdateUserScreen();\n        },\n      ),\n    );\n  }\n  \n  @override\n  Widget build(BuildContext context) {\n    return new Scaffold(\n      appBar: new AppBar(\n        title: new Text('Inherited Widget Test'),\n      ),\n      body: _logInPrompt,\n      floatingActionButton: new FloatingActionButton(\n        onPressed: () => _updateUser(context),\n        child: new Icon(Icons.edit),\n      ),\n    );\n  }\n}\n```\n\n### 3. The UpdateUserScreen Widget\n\nFinally, a form page that does nothing, for now.\n\n\n```dart\nclass UpdateUserScreen extends StatelessWidget {\n  static final GlobalKey<FormState> formKey = new GlobalKey<FormState>();\n  static final GlobalKey<FormFieldState<String>> firstNameKey =\n  new GlobalKey<FormFieldState<String>>();\n  static final GlobalKey<FormFieldState<String>> lastNameKey =\n  new GlobalKey<FormFieldState<String>>();\n  static final GlobalKey<FormFieldState<String>> emailKey =\n  new GlobalKey<FormFieldState<String>>();\n\n  const UpdateUserScreen({Key key}) : super(key: key);\n\n  @override\n  Widget build(BuildContext context) {\n    \n    return new Scaffold(\n      appBar: new AppBar(\n        title: new Text('Edit User Info'),\n      ),\n      body: new Padding(\n        padding: new EdgeInsets.all(16.0),\n        child: new Form(\n          key: formKey,\n          autovalidate: false,\n          child: new ListView(\n            children: [\n              new TextFormField(\n                key: firstNameKey,\n                style: Theme.of(context).textTheme.headline,\n                decoration: new InputDecoration(\n                  hintText: 'First Name',\n                ),\n              ),\n              new TextFormField(\n                key: lastNameKey,\n                style: Theme.of(context).textTheme.headline,\n                decoration: new InputDecoration(\n                  hintText: 'Last Name',\n                ),\n              ),\n              new TextFormField(\n                key: emailKey,\n                style: Theme.of(context).textTheme.headline,\n                decoration: new InputDecoration(\n                  hintText: 'Email Address',\n                ),\n              )\n            ],\n          ),\n        ),\n      ),\n      floatingActionButton: new FloatingActionButton(\n        child: new Icon(Icons.add),\n        onPressed: () {\n          final form = formKey.currentState;\n          if (form.validate()) {\n            var firstName = firstNameKey.currentState.value;\n            var lastName = lastNameKey.currentState.value;\n            var email = emailKey.currentState.value;\n\n            // Later, do some stuff here\n\n            Navigator.pop(context);\n          }\n        },\n      ),\n    );\n  }\n}\n```\n[Here's a GitHub Gist of the boiler plate.](https://gist.github.com/ericwindmill/32e73cc1fbf65114b5aa875500395f5a)\n\n##Pt 2: Add in Inherited Widget Functionality\n\n\n\n### 1. StateContainer and InheritedStateContainer Widgets\n\nMake a new file called `state_container.dart`. This is where all things happen.\n\nFirst, in that file, create a simple class called `User`. In a real app, this could be a bigger class called \n`AppState`, where you'd hold all the properties you want to access across your app.\n\n```dart\nclass User {\n  String firstName;\n  String lastName;\n  String email;\n\n  User(this.firstName, this.lastName, this.email);\n}\n```\n\nThe InheritedWidget works as store by connecting to an StatefulWidget. So your StateContainer is really three classes:\n\n```dart\nclass StateContainer extends StatefulWidget\nclass StateContainerState extends State<StateContainer>\nclass _InheritedStateContainer extends InheritedWidget\n```\n\nThe `InheritedWidget` and the `StateContainer` are the simplest to set up, and once they're set up they don't change.\n The logic mainly lives in `StateContainerState`. Set up the first two:\n \n \n \n \n ```dart\n class _InheritedStateContainer extends InheritedWidget {\n    // Data is your entire state. In our case just 'User' \n   final StateContainerState data;\n    \n   // You must pass through a child and your state.\n   _InheritedStateContainer({\n     Key key,\n     @required this.data,\n     @required Widget child,\n   }) : super(key: key, child: child);\n \n   // This is a built in method which you can use to check if\n   // any state has changed. If not, no reason to rebuild all the widgets\n   // that rely on your state.\n   @override\n   bool updateShouldNotify(_InheritedStateContainer old) => true;\n }\n \n class StateContainer extends StatefulWidget {\n    // You must pass through a child. \n   final Widget child;\n   final User user;\n \n   StateContainer({\n     @required this.child,\n     this.user,\n   });\n \n   // This is the secret sauce. Write your own 'of' method that will behave\n   // Exactly like MediaQuery.of and Theme.of\n   // It basically says 'get the data from the widget of this type.\n   static StateContainerState of(BuildContext context) {\n     return (context.inheritFromWidgetOfExactType(_InheritedStateContainer)\n             as _InheritedStateContainer).data;\n   }\n   \n   @override\n   StateContainerState createState() => new StateContainerState();\n }\n ```\nThat 'of' method should really never do anything else. In fact those two classes can just be left alone forever.\n\n\n### 2. StateContainerState Widget\n\nThis Widget is where all your state and logic *can* live. For this app, you'll simply be able to store and manipulate\n your user.\n \n```dart\nclass StateContainerState extends State<StateContainer> {\n  // Whichever properties you wanna pass around your app as state\n  User user;\n\n  // You can (and probably will) have methods on your StateContainer\n  // These methods are then used through our your app to \n  // change state.\n  // Using setState() here tells Flutter to repaint all the \n  // Widgets in the app that rely on the state you've changed.\n  void updateUserInfo({firstName, lastName, email}) {\n    if (user == null) {\n      user = new User(firstName, lastName, email);\n      setState(() {\n        user = user;\n      });\n    } else {\n      setState(() {\n        user.firstName = firstName ?? user.firstName;\n        user.lastName = lastName ?? user.lastName;\n        user.email = email ?? user.email;\n      });\n    }\n  }\n\n  // Simple build method that just passes this state through\n  // your InheritedWidget\n  @override\n  Widget build(BuildContext context) {\n    return new _InheritedStateContainer(\n      data: this,\n      child: widget.child,\n    );\n  }\n}\n``` \n\nIf you've used Redux in the past, you can see how much less boiler plate is involved here. Theres far less opinions, \nwhich of course comes with potential for bugs, but for a simple app, this is fantastic. This is literally *all* the \nwork it takes to set up your Store. Then you just add properties and methods to that class as you need them.\n\n### 3. Refactor Home and Form screens\n\nFirst, wrap your app in the StateContainer:\n\n```dart\nvoid main() {\n  runApp(new StateContainer(child: new UserApp()));\n}\n```\n\nThat's it: now you can access your store all over the app. So do that:\n\n```dart\n// main.dart\n// ... \nclass HomeScreenState extends State<HomeScreen> {\n  // Make a class property for the data you want\n  User user;\n\n  // This Widget will display the users info:\n  Widget get _userInfo {\n    return new Center(\n      child: new Column(\n        mainAxisAlignment: MainAxisAlignment.center,\n        crossAxisAlignment: CrossAxisAlignment.center,\n        children: <Widget>[\n          // This refers to the user in your store\n          new Text(\"${user.firstName} ${user.lastName}\",\n              style: new TextStyle(fontSize: 24.0)),\n          new Text(user.email, style: new TextStyle(fontSize: 24.0)),\n        ],\n      ),\n    );\n  }\n\n  Widget get _logInPrompt {\n    // ...\n  }\n\n  void _updateUser(BuildContext context) {\n    // ...\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    // This is how you access your store. This container\n    // is where your properties and methods live\n    final container = StateContainer.of(context);\n    \n    // set the class's user\n    user = container.user;\n    \n    var body = user != null ? _userInfo : _logInPrompt;\n    \n    return new Scaffold(\n      appBar: new AppBar(\n        title: new Text('Inherited Widget Test'),\n      ),\n      // The body will rerender to show user info\n      // as its updated\n      body: body,\n      floatingActionButton: new FloatingActionButton(\n        onPressed: () => _updateUser(context),\n        child: new Icon(Icons.edit),\n      ),\n    );\n  }\n}\n```\n\nPretty simple changes there. And the form page isn't much different:\n\n```dart\n// form_page.dart\n// ...\nclass UpdateUserScreen extends StatelessWidget {\n  // ...\n\n  @override\n  Widget build(BuildContext context) {\n    // get reference to your store\n    final container = StateContainer.of(context);\n    \n    return new Scaffold(\n      // the form is the same until here:\n      floatingActionButton: new FloatingActionButton(\n        child: new Icon(Icons.add),\n        onPressed: () {\n          final form = formKey.currentState;\n          if (form.validate()) {\n            var firstName = firstNameKey.currentState.value;\n            var lastName = lastNameKey.currentState.value;\n            var email = emailKey.currentState.value;\n\n            // This is a hack that isn't important\n            // To this lesson. Basically, it prevents \n            // The store from overriding user info\n            // with an empty string if you only want\n            // to change a single attribute\n            if (firstName == '') {\n              firstName = null;\n            }\n            if (lastName == '') {\n              lastName = null;\n            }\n            if (email == '') {\n              email = null;\n            }\n\n            // You can call the method from your store,\n            // which will call set state and rerender\n            // the widgets that rely on the user slice of state.\n            // In this case, thats the home page\n            container.updateUserInfo(\n              firstName: firstName,\n              lastName: lastName,\n              email: email,\n            );\n            \n            Navigator.pop(context);\n          }\n        },\n      ),\n    );\n  }\n}\n\n```\n\n\nThat's it! The InheritedWidget is easy, and an extremely viable option for simple apps, prototypes, etc.\n\n[Here are the completed files on GitHub Gist](https://gist.github.com/ericwindmill/f790bd2456e6489b1ab97eba246fd4c6)","updated_at":"Saturday, 27th of June, 2020","slug":"using-flutter-inherited-widgets-effectively","strapiId":3,"title":"Using Flutter Inherited Widgets Effectively","tags":[{"title":"flutter"},{"title":"state management"}]}},"pageContext":{"slug":"using-flutter-inherited-widgets-effectively"}}}